# 召回率提升方案 (95.8% → ≥98%)

**当前评测结果**：
- 构建时间：**1500s** ⚠️ 接近限制但安全
- 召回率@10：**95.8%** ❌ 低于98%要求
- 搜索时间：**1.38ms** ✅ 优秀

**本地测试结果对比**：
- 构建时间：362s（本地） vs 1500s（评测） → **差距4.1倍**
- 召回率：98.4%（本地） vs 95.8%（评测） → **差距2.6%**

**差距2.6%的原因**：需要 +2.2% 才能达标

---

## 一、问题诊断

### 🔴 **核心问题：召回率95.8% vs 要求98%**

**差距分析**：
- 本地测试达到 98.4%，说明算法和参数基本正确
- 评测环境低 2.6%，可能原因：
  1. **随机性差异**：`get_random_level()` 使用线程相关随机数，不同环境层级分配不同
  2. **图质量波动**：并行构建的非确定性导致图结构差异
  3. **数值精度**：不同CPU的浮点计算精度略有差异
  4. **编译优化**：评测环境可能未启用 `-march=native` 导致性能下降

**关键指标**：
- 需要提升：+2.2% → 目标 98%+
- 安全余地：最好达到 98.5%+ 以应对波动

---

### ⚠️ **次要问题：构建时间1500s接近上限**

**风险评估**：
- 当前：1500s / 2000s = 75% 利用率
- 安全余地：500s（约8分钟）
- 可用于优化：最多增加 300-400s

---

## 二、优化方案（按优先级）

### 🟢 **优先级1：提升 EF_SEARCH（零风险，立即执行）** ⭐

**当前**：`EF_SEARCH = 400`  
**建议**：`EF_SEARCH = 500` 或 `600`

**理由**：
- ✅ **不影响构建时间**（构建阶段不使用此参数）
- ✅ 对召回率有显著提升（通常 +0.5-1.5%）
- ✅ 搜索时间从 1.38ms 增加到 ~2-3ms，仍然很快
- ✅ 零风险方案

**预期效果**：
- `EF_SEARCH = 500`：召回率 +0.8-1.2% → **96.6-97%**
- `EF_SEARCH = 600`：召回率 +1.2-1.8% → **97-97.6%**

**结论**：单独提升可能不够，需要配合其他方案

---

### 🟡 **优先级2：提升 EF_CONSTRUCTION（中等风险）**

**当前**：`EF_CONSTRUCTION = 250`  
**建议**：`EF_CONSTRUCTION = 350` 或 `400`

**理由**：
- 提升构建时的候选池质量
- 直接影响图的连接质量
- 对召回率提升明显

**代价分析**：
```
EF_C 从 250 → 350：构建时间增加约 30-40%
1500s × 1.35 = 2025s （超时风险！）

EF_C 从 250 → 300：构建时间增加约 15-20%
1500s × 1.18 = 1770s （安全）
```

**推荐方案**：
- **保守**：`EF_CONSTRUCTION = 300`（+18%时间，约270s）
- **激进**：`EF_CONSTRUCTION = 320`（+25%时间，约375s）

**预期效果**：
- `EF_C = 300`：召回率 +0.5-1.0% → **96.3-96.8%**
- `EF_C = 320`：召回率 +0.8-1.3% → **96.6-97.1%**

---

### 🟡 **优先级3：组合方案（推荐）** ⭐⭐⭐

**方案A：稳妥方案**
```cpp
M = 36                  // 保持不变
EF_CONSTRUCTION = 300   // +20% 构建时间
EF_SEARCH = 550         // 零影响
```

**预期**：
- 构建时间：1500s × 1.20 = **1800s**（安全）
- 召回率：95.8% + 1.0% + 1.2% = **98.0%**（刚好达标）
- 搜索时间：~2.5ms（仍然优秀）

---

**方案B：激进方案**
```cpp
M = 36                  // 保持不变
EF_CONSTRUCTION = 320   // +25% 构建时间
EF_SEARCH = 600         // 零影响
```

**预期**：
- 构建时间：1500s × 1.25 = **1875s**（接近上限但安全）
- 召回率：95.8% + 1.2% + 1.5% = **98.5%**（有余地）
- 搜索时间：~3ms

---

**方案C：保守备用方案**
```cpp
M = 40                  // 增加边数（+10% 构建时间）
EF_CONSTRUCTION = 280   // 微增（+12% 构建时间）
EF_SEARCH = 500         // 零影响
```

**预期**：
- 构建时间：1500s × 1.23 = **1845s**（安全）
- 召回率：95.8% + 0.5% + 0.8% + 1.0% = **98.1%**（达标）

---

### 🟢 **优先级4：仅提升 EF_SEARCH（最安全但可能不够）**

如果担心超时，先只改这一个参数试试：

```cpp
M = 36
EF_CONSTRUCTION = 250
EF_SEARCH = 700  // 大幅提升
```

**预期**：
- 构建时间：**1500s**（不变）
- 召回率：95.8% + 2.0% = **97.8%**（接近但可能不够）
- 搜索时间：~3-4ms（可接受）

---

## 三、实施建议

### 📋 **推荐执行顺序**

**第一步：方案A（稳妥）**
1. 修改参数：`EF_C=300, EF_S=550`
2. 本地测试验证召回率 > 99%
3. 提交评测
4. 如果召回率仍不足，执行第二步

**第二步：方案B（激进）**
1. 修改参数：`EF_C=320, EF_S=600`
2. 重新测试
3. 提交评测

**第三步：方案C（保险）**
1. 同时增加 M 到 40
2. 这是最后手段

---

## 四、风险评估

### ⚠️ **构建时间超时风险矩阵**

| 配置 | EF_C | 预估本地时间 | 预估评测时间 | 超时概率 | 召回率预估 |
|------|------|------------|------------|---------|----------|
| **当前** | 250 | 362s | 1500s | 0% | 95.8% ❌ |
| **方案A** | 300 | 430s | 1800s | 5% | 98.0% ✅ |
| **方案B** | 320 | 450s | 1875s | 15% | 98.5% ✅ |
| **方案C** | 280+M=40 | 445s | 1845s | 10% | 98.1% ✅ |
| **极限** | 350 | 490s | 2030s | 50% ⚠️ | 98.8% ✅ |

---

### 📊 **参数调优速查表**

| M | EF_C | EF_S | 构建时间 | 召回率 | 搜索时间 | 推荐度 |
|---|------|------|---------|--------|---------|--------|
| 36 | 250 | 400 | 1500s | 95.8% | 1.4ms | ❌ 当前（不达标） |
| 36 | 250 | 600 | 1500s | 97.5% | 3ms | ⚠️ 可能不够 |
| 36 | 300 | 550 | 1800s | 98.0% | 2.5ms | ✅ **推荐** |
| 36 | 320 | 600 | 1875s | 98.5% | 3ms | ✅ 激进但安全 |
| 40 | 280 | 500 | 1845s | 98.1% | 2ms | ✅ 备用方案 |
| 40 | 300 | 600 | 1950s | 98.8% | 3ms | ⚠️ 接近极限 |

---

## 五、其他优化考虑

### 🔧 **如果上述方案仍不够（召回率 < 98%）**

**深层次问题排查**：

1. **检查 RobustPrune 实现**
   - 当前代码中可能仍有 pruning 逻辑不完整的地方
   - 特别是反向连接的 prune 可能过于激进

2. **检查随机数种子**
   ```cpp
   // 当前实现
   static thread_local std::mt19937 rng(12345 + std::hash<std::thread::id>{}(...));
   
   // 可能改进：使用固定种子确保可重复性
   static thread_local std::mt19937 rng(12345);
   ```

3. **增加 re-ranking 候选数**
   - 当前 `search_layer_query` 返回的候选集大小 = EF_SEARCH
   - 可以增加到 `EF_SEARCH * 1.5` 然后 re-rank

4. **检查 flattened graph 的正确性**
   - Layer 0 扁平化后的图可能有访问错误
   - 验证 `final_graph_offsets` 和 `final_graph_flat` 是否正确

---

## 六、终极方案（最后手段）

如果所有方案都不能达到 98%，考虑：

### 🚨 **终极组合**
```cpp
M = 40                  // 增加连接度
EF_CONSTRUCTION = 350   // 大幅提升构建质量
EF_SEARCH = 800         // 极限搜索范围
```

**代价**：
- 构建时间：~2000s（极限）
- 搜索时间：~5ms（仍可接受）

**预期**：
- 召回率：99%+（几乎确保达标）

---

## 七、调试建议

### 🔍 **在修改前验证**

**本地测试脚本**：
```powershell
# 测试不同配置的召回率波动
for ($i = 1; $i -le 5; $i++) {
    Write-Host "`n=== Test Run $i ===" -ForegroundColor Cyan
    .\test_solution.exe ..\data_o\data_o\glove 2>&1 | Select-String "Recall@10"
}
```

**分析波动范围**：
- 如果本地 5 次测试的召回率波动 > 1%，说明随机性影响大
- 需要考虑增大参数以减少波动

---

## 八、总结与行动计划

### ✅ **立即执行（推荐方案A）**

**代码修改**：
```cpp
// MySolution.cpp 第 15-17 行
static const int M = 36;
static const int EF_CONSTRUCTION = 300;  // 从 250 增加到 300
static const int EF_SEARCH = 550;        // 从 400 增加到 550
```

**预期结果**：
- ✅ 构建时间：~1800s（安全余地200s）
- ✅ 召回率：98.0-98.3%（达标）
- ✅ 搜索时间：~2.5ms（优秀）

**如果方案A不够，升级到方案B**：
```cpp
static const int EF_CONSTRUCTION = 320;  // 再增加
static const int EF_SEARCH = 600;
```

---

### 📌 **关键要点**

1. **优先提升 EF_SEARCH**：零成本，必做
2. **谨慎提升 EF_CONSTRUCTION**：权衡时间与召回率
3. **保持 M=36**：除非其他方法都失败
4. **留出安全余地**：目标 98.5% 而非刚好 98%

---

### 🎯 **成功标准**

- 构建时间 < 1900s（留100s余地）
- 召回率 ≥ 98.5%（留0.5%波动余地）
- 搜索时间 < 5ms（充足）

**如果达到以上标准，即可提交！**
